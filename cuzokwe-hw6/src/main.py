# -*- coding: utf-8 -*-
"""ECET 512 HW6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bUVVRS9bcd93op34owmiuiHHrV8rnZlA

Bartlett Beamformer
"""

import numpy as np
import math
from cmath import exp
from math import cos
from math import sin

"""## Plot User Movement

Functions
"""

import matplotlib.pyplot as plt
import numpy as np
from matplotlib import animation, rc
from IPython.display import HTML
import cmath

ni = 1
nj = 2
N = ni**2 + ni*nj + nj**2
center = [0,0]
radius = 2000/np.sqrt(3)
labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
subscripts = ['\u2081', '\u2082', '\u2083', '\u2084', '\u2085', '\u2086', '\u2087']
frequencies = [1.8E9, 1.82E9, 1.84E9, 1.86E9, 1.88E9, 868E6, 882E6]

def hexangles(x): return np.pi*x/6

def drawCell(center,radius,label):
    pts = list(range(0,14,2))
    theta = list(map(hexangles,pts))
    xs = center[0]+radius*np.cos(theta)
    ys = center[1]+radius*np.sin(theta)
    plt.plot(xs,ys,'b-')
    plt.text(center[0],center[1],label)

def findServingCell(mobileLocation, cellCenters):
  distances = [np.sqrt((mobileLocation[0]-cell[0])**2 + (mobileLocation[1]-cell[1])**2)  for cell in cellCenters]
  return distances.index(min(distances)), min(distances)

channels = [[0,0]]
zippedcells = []

"""Mobile User on Cell"""

fig = plt.figure()
ax = plt.gca()
ax.set_aspect(1)

ax.set_title('Array Antenna Uplink Animation')
ax.set_xlabel('X (meters)')
ax.set_ylabel('Y (meters)')

plt.rcParams['animation.ffmpeg_path'] = '/usr/local/bin/ffmpeg'
numFrames = 60
ims=[]
mobilePosX = np.linspace(-65, 40,numFrames)
mobilePosY = np.linspace(78,22,numFrames)


mobileAngle = np.arange(0, 2*np.pi, 2*np.pi/numFrames)
mobilePosX = [40*cos(x) for x in mobileAngle]
mobilePosY = [40*sin(x) for x in mobileAngle]



zippedcells = []
distances = []
targetcells = []
drawCell([0,0], 100, 'Smart Array')
angles = []

for frames in range(numFrames):
   
   # Find the corresponding serving cell
   idx, distance = findServingCell([mobilePosX[frames],mobilePosY[frames]], [[0,0]])

   #print(channels[idx][0])
   distances.append(distance)
   #targetcells.append(zippedcells[idx])
   # Draw a line connecting the center (basestation) of the serving cell 
   # and the mobile user
   #im, = plt.plot([0,mobilePosX[frames]],[0,mobilePosY[frames]], marker = 'x', color = 'red', animated=True)

   im, = plt.plot( [0,mobilePosX[frames]], [0,mobilePosY[frames]], marker = 'x', color = 'red', animated=True)
   theta = math.atan2(mobilePosY[frames], mobilePosX[frames])
   #theta = (theta+2*np.pi)%(2*np.pi)
   angles.append(theta)



   # Draw the mobile user at the appropriate location
   #im2, = plt.plot(mobilePosX[frames],mobilePosY[frames],'r+', animated=True)
    
   ims.append([im])

ani = animation.ArtistAnimation(fig, ims, interval=50, blit=True, repeat_delay=1000)

rc('animation', html='jshtml')
ani
#ani.save('user.gif', writer='pillow')
#plt.show()

mobileAngle = np.arange(0, 2*np.pi, 2*np.pi/numFrames)

len(mobileAngle)

# steering vector
def st_vec_lin(theta, M, d, k):
  alu = np.array([], dtype=np.float64)
  inc = d
  for i in range(M)[::-1]:
    r = exp(-1j*k*d*(M-i+1)*cos(theta))
    d= d+inc
    alu = np.append(alu, r)

  return alu

alu_vecs = []
l = 1/1.8E9
M = 10
d = l/10
k = 2*np.pi/l

def bs_power(d):
  return 0 - 10*2.9*np.log10(d)


for i in range(numFrames):
  alu = st_vec_lin(mobileAngle[i], M, d, k)
  alu_vecs.append(alu)


x = []
# array output
for  i in range(numFrames):
  out = alu_vecs[i] + np.random.normal(0, 1, 1)
  out = out.reshape(len(out),1)
  x.append(out)

x = np.asarray(x)

# spatial covariance matrix 

def R_est(N, x, Ts):
  R = []
  #xH = x.conjugate().T
  sum = 0
  for i in range(N):
    #print(x[i*Ts].conjugate().shape)
    sum += np.dot(x[i*Ts],x[i*Ts].conjugate().T)
   # print(sum)

  return sum/N

R = R_est(60, x, 1)

# power
P = []
for i in range(numFrames):
  power = np.dot(alu_vecs[i].conjugate().T, (R*alu_vecs[i]))/np.dot(alu_vecs[i].conjugate().T, alu_vecs[i])
  #print(power)
  P.append(power.sum())

theta_est = []
for i in range(numFrames):
  theta_est.append(np.argmax(P[i]))

pf = []
vecth = []
for i in range(numFrames):
  pf.append(P[i][theta_est[i]])
  vecth.append(alu_vecs[i][theta_est[i]])

plt.figure(figsize=(10,10))
plt.polar(mobileAngle, P)
plt.title('Bartlett Beam - inter-element sweep lambda/10 - lambda')

P[0][0]