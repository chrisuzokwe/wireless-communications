# -*- coding: utf-8 -*-
"""ECET 512 HW8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fdn2fdDfQPR_jmEP0KpQPZffxcs8EefP
"""

import numpy as np
import matplotlib.pyplot as plt
import random

"""# Fading Statistics

#### Generating Fading Signals
"""

def rayleighfade(N, fm):
  # return rayleigh time samples

  df = (2*fm)/(N-1)
  T = 1/df

  # generating doppler spectrum
  spectrum = np.arange(-fm, fm+(df*1/2), df)

  dspectrum = np.sqrt([1.5/(np.pi*fm*np.sqrt(1-(f/fm)**2)) for f in spectrum])
  dspectrum[0]=2*dspectrum[1]-dspectrum[2]
  dspectrum[-1]=2*dspectrum[-2]-dspectrum[-3] 

  # Gaussian RVs and Frequency Spectrum
  pos = np.array([])
  pos2 = np.array([])

  for i in range(int(N/2)):
    pos = np.append(pos, [np.random.normal(0, 1) + 1j*np.random.normal(0, 1)])
    pos2 = np.append(pos2, [np.random.normal(0, 1) + 1j*np.random.normal(0, 1)])

  neg = np.flip(np.conj(pos))
  neg2 = np.flip(np.conj(pos2))

  gaus1 = np.concatenate((neg, pos))
  gaus2 = np.concatenate((neg2, pos2))

  # Shaping Gaussians by Dspectrum
  X = gaus1*np.sqrt(dspectrum)
  Y = gaus2*np.sqrt(dspectrum)

  tX = np.abs(np.fft.ifft(X))**2
  tY = np.abs(np.fft.ifft(Y))**2

  r = np.sqrt(tX+tY)

  return r, T

r20, T20 = rayleighfade(100, 20)
r20rms = np.sqrt(sum(r20**2)/100)
r20norm = r20/r20rms

r200, T200 = rayleighfade(100, 200)
r200rms = np.sqrt(sum(r200**2)/100)
r200norm = r200/r200rms

plt.figure(figsize=(25, 10))

plt.xlabel('Time (sec)')
plt.ylabel('Magnitude (dB)')

plt.grid(True)
plt.title('Rayleigh Fading Channel: fm=20\n @RMS = 0dB \n AFD  = 0.061875 \n LCR per 1sec=10.101 \n @RMS = -10dB \n AFD = 0.02475 \n LCR per 1sec=2.8282')
plt.xlim(0, 2.5)
t20 =np.arange(0, T20, T20/100)
plt.plot(t20[:100], 20*np.log10(r20norm), color='green', label='Amplitude')
plt.axhline(0, label='RMS LEVEL', color='k', linestyle='--')
plt.axhline(-10, label='10 dB below RMS LEVEL', color='red', linestyle='--')
plt.legend()

plt.figure(figsize=(25, 10))

plt.xlabel('Time (sec)')
plt.ylabel('Magnitude (dB)')

plt.grid(True)
plt.title('Rayleigh Fading Channel: fm=200\n @RMS = 0dB \n AFD  = 0.0058 \n LCR per 1sec=101.01 \n @RMS = -10dB \n AFD = 0.003024 \n LCR per 1sec=36.36')
plt.xlim(0, 0.25)
t200 =np.arange(0, T200, T200/100)
plt.plot(t200[:100], 20*np.log10(r200norm), color='green', label='Amplitude')
plt.axhline(0, label='RMS LEVEL', color='k', linestyle='--')
plt.axhline(-10, label='10 dB below RMS LEVEL', color='red', linestyle='--')
plt.legend()

"""#### Zero-Crossing """

def crossing_rate(sig, thresh):

  above = True if sig[0] > thresh else False
  crossings = 0

  for i in sig:
    if above and i < thresh:
      crossings += 1
      above = False

    elif not above and i > thresh:
      above = True
    
    else:
      pass

  return crossings

# 20fm crossing rate
c20t0 = crossing_rate(20*np.log10(r20norm), 0)
c20t10 = crossing_rate(20*np.log10(r20norm), -10)
print(c20t0)
print(c20t10)

# Level Crossing Rate
lcr20t0 = c20t0*(1/T20)
lcr20t10 = c20t10*(1/T20)
print(lcr20t0)
print(lcr20t10)

# 200fm crossing rate
c200t0 = crossing_rate(20*np.log10(r200norm), 0)
c200t10 = crossing_rate(20*np.log10(r200norm), -10)

print(c200t0)
print(c200t10)

# Level Crossing Rate
lcr200t0 = c200t0*(1/T200)
lcr200t10 = c200t10*(1/T200)
print(lcr200t0)
print(lcr200t10)

"""#### Average Fade Duration"""

def average_fade(sig, time, thresh):
  above = True if sig[0] > thresh else False
  crossings = 0
  fadetotal = 0
  intervals = 0
  dt = 0

  for sample, time in zip(sig, time):

    if above and sample < thresh:
      crossings += 1
      above = False
      dt = time

    elif not above and sample > thresh:
      above = True
      fadetotal += time-dt
      intervals += 1
    
    else:
      pass

  return fadetotal/intervals

t20 =np.arange(0, T20, T20/100)
afd20fm = average_fade(20*np.log10(r20norm), t20, 0)
print(afd20fm)

t20 =np.arange(0, T20, T20/100)
afd20fm10 = average_fade(20*np.log10(r20norm), t20, -10)
print(afd20fm10)

t200 =np.arange(0, T200, T200/100)
afd200fm = average_fade(20*np.log10(r200norm), t200, 0)
print(afd200fm)

t200 =np.arange(0, T200, T200/100)
afd200fm = average_fade(20*np.log10(r200norm), t200, -10)
print(afd200fm)

def ispositive(x): return 1 if x >= 0 else 0

"""## MISO Functions"""

def encoded_bit_gen(N):
  # generate bit string
  bits = np.zeros(N*2, dtype=int)

  for i in range(N*2):
    bits[i] = random.randint(0, 1)

  # create encoded bit sequence
  bitsencoded = []

  for i in range(int(len(bits)/2)):

    b1 = bits[2*i]
    b2 = bits[2*i+1]
    
    if b1 and b2:
      bitsencoded.append(-1+1j)
    elif (not b1) and b2:
      bitsencoded.append(1+1j)
    elif b1 and (not b2):
      bitsencoded.append(-1-1j)
    elif (not b1) and (not b2):
      bitsencoded.append(1-1j)

  return bits, bitsencoded

"""# MISO with Selection Diversity and Maximal Ratio Combining"""

k=4
n_samples= 5000

X = np.array([])
bits, x = encoded_bit_gen(n_samples)

for i in range(k):
  X = np.hstack((X, x))

X = X.reshape((k, n_samples))

N = np.array([])

for i in range(k):
  N = np.hstack((N ,np.random.normal(0, 1, n_samples)))

N = N.reshape((k, n_samples))

H = np.array([])

for i in range(k):
  r, T = rayleighfade(n_samples, 20)
  theta = np.exp(-1j*np.random.uniform(0, 2*np.pi, n_samples))
  h = r*theta

  H = np.hstack((H, h))

H= H.reshape((k, n_samples))
H.shape

Y = H*X + N

Yest = (H**-1)*Y

Yest

ySNR= []
No = 1000

for i in range(k):
  ySNR.append(np.mean(Yest[i,:]**2)/No)

ySNR
np.argmax(ySNR)

def ispositive(x): return 1 if x >= 0 else 0

selected_reciever = np.argmax(ySNR)
signal = Yest[selected_reciever,:].copy()

eq_decoded = []

for i in signal:

  real = np.real(i)
  imag = np.imag(i)

  eq_decoded.append(ispositive(real*-1))
  eq_decoded.append(ispositive(imag))

eq_decoded = np.array(eq_decoded)

err = 0
for i in range(len(x)):

  if bits[i] != eq_decoded[i]:
    err += 1

print(err/10000)

"""# MISO w/ Selection Diversity SNR vs. BER"""

def miso_simulator(No = 1000):

  k=4
  n_samples= 5000
  Eb = 1

  noise = Eb/No

  X = np.array([])
  bits, x = encoded_bit_gen(n_samples)

  for i in range(k):
    X = np.hstack((X, x))

  X = X.reshape((k, n_samples))

  N = np.array([])
  

  for i in range(k):
    N = np.hstack((N ,np.random.normal(0, 1, n_samples)*noise))

  N = N.reshape((k, n_samples))

  H = np.array([])

  for i in range(k):
    r, T = rayleighfade(n_samples, 20)
    theta = np.exp(-1j*np.random.uniform(0, 2*np.pi, n_samples))
    h = r*theta

    H = np.hstack((H, h))
  
  H= H.reshape((k, n_samples))
  Y = H*X + N
  Yest = (1/H)*Y

  ySNR= []

  for i in range(k):
    ySNR.append(np.mean(Yest[i,:]**2)/No)

  selected_reciever = np.argmax(ySNR)
  signal = Yest[selected_reciever,:].copy()

  eq_decoded = []

  for i in signal:

    real = np.real(i)
    imag = np.imag(i)

    eq_decoded.append(ispositive(real*-1))
    eq_decoded.append(ispositive(imag))

  eq_decoded = np.array(eq_decoded)

  err = 0
  for i in range(len(bits)):

    if bits[i] != eq_decoded[i]:
      err += 1

  return err/10000, noise

miso_simulator(1)

SD_BERs = []
SD_SNRs = []
NP = np.linspace(0, 1000, 1000)

for i in NP:
  BER, SNR = miso_simulator(i)

  SD_BERs.append(BER)
  SD_SNRs.append(SNR)

plt.figure(figsize=(25, 10))

plt.xlabel('Eb/No (dB)')
plt.ylabel('BER')

plt.grid(True)
plt.title('Bit Error Rate vs. SNR for MISO System with Selection Diversity')
plt.ylim(10E-4, 5E-1)
plt.plot(-10*np.log10(SD_SNRs), SD_BERs, color='red')



"""# MISO w/ Maximum Ratio Combining SNR vs. BER"""

def miso_simulator_mrc(No = 1000):

  k=4
  n_samples= 5000
  Eb = 1

  noise = Eb/No

  X = np.array([])
  bits, x = encoded_bit_gen(n_samples)

  for i in range(k):
    X = np.hstack((X, x))

  X = X.reshape((k, n_samples))

  N = np.array([])
  

  for i in range(k):
    N = np.hstack((N ,np.random.normal(0, 1, n_samples)*noise))

  N = N.reshape((k, n_samples))

  H = np.array([])

  for i in range(k):
    r, T = rayleighfade(n_samples, 20)
    theta = np.exp(-1j*np.random.uniform(0, 2*np.pi, n_samples))
    h = r*theta

    H = np.hstack((H, h))
  
  H= H.reshape((k, n_samples))
  Y = H*X + N
  Yest = (1/H)*Y

  Ysel = np.zeros((5000, 1), dtype='complex128') #dtype=complex128)

  #print(np.mean(abs(Yest[0,:])))
  #print(Yest[0,:])
  #print((Yest[0,:]*np.mean(abs(Yest[0,:]))).shape)

  for i in range(k):
    channel = Yest[i,:]*np.mean(abs(Yest[i,:]))
    #Ysel += channel
    for j in range(len(channel)):
      Ysel[j] += channel[j]
    

  ySNR= []

  for i in range(k):
    ySNR.append(np.mean(Yest[i,:]**2)/No)

  selected_reciever = np.argmax(ySNR)
  signal = Yest[selected_reciever,:].copy()

  eq_decoded = []

  for i in Ysel:

    #print(i)
    real = np.real(i)
    imag = np.imag(i)

    eq_decoded.append(ispositive(real*-1))
    eq_decoded.append(ispositive(imag))

  eq_decoded = np.array(eq_decoded)

  err = 0
  for i in range(len(bits)):

    if bits[i] != eq_decoded[i]:
      err += 1

  return err/10000, noise

miso_simulator_mrc(1)

SD_BERs = []
SD_SNRs = []
NP = np.linspace(0, 1000, 1000)

for i in NP:
  BER, SNR = miso_simulator(i)

  SD_BERs.append(BER)
  SD_SNRs.append(SNR)

plt.figure(figsize=(25, 10))

plt.xlabel('Eb/No (dB)')
plt.ylabel('BER')

plt.grid(True)
plt.title('Bit Error Rate vs. SNR for MISO System with Maximum Ratio Combining')
plt.ylim(10E-4, 5E-1)
plt.plot(-10*np.log10(SD_SNRs), SD_BERs, color='red')



"""# MISO w/ Spatial Multiplexing SNR vs. BER"""

def spatial_mux(No = 1000):

  k=2
  n_samples= 5000
  Eb = 1

  noise = Eb/No

  X = np.array([])
  allbits = np.array([])
  #bits, x = encoded_bit_gen(n_samples)

  for i in range(2):
    bits, x = encoded_bit_gen(n_samples)
    allbits = np.hstack((allbits, bits))
    X = np.hstack((X, x))

  allbits = allbits.reshape((2, n_samples*2))
  X = X.reshape((2, n_samples))

  N = np.array([])
  

  for i in range(2):
    N = np.hstack((N ,np.random.normal(0, 1, n_samples)*noise))

  N = N.reshape((2, n_samples))

  H1 = np.array([])
  H2 = np.array([])

  for i in range(2):
    r, T = rayleighfade(n_samples, 20)
    theta = np.exp(-1j*np.random.uniform(0, 2*np.pi, n_samples))
    h1 = r*theta
    H1 = np.hstack((H1, h1))

    r, T = rayleighfade(n_samples, 20)
    theta = np.exp(-1j*np.random.uniform(0, 2*np.pi, n_samples))
    h2 = r*theta
    H2 = np.hstack((H2, h2))
  
  
  H1= H1.reshape((2, n_samples))
  H2= H2.reshape((2, n_samples))

  Y1em = H1[0,:]*X[0,:] + H1[1,:]*X[0,:] + N[0,:]
  Y2 = H2[0,:]*X[1,:] + H2[1,:]*X[1,:] + N[1,:]

  Y1 = (1/H1[0,:])*Y1 + (1/H1[1,:])*Y1
  Y2 = (1/H1[0,:])*Y2 + (1/H2[1,:])*Y2

  ySNR= []

  #for i in range(k):
  #  ySNR.append(np.mean(Yest[i,:]**2)/No)

  #selected_reciever = np.argmax(ySNR)
  #signal = Yest[selected_reciever,:].copy()

  eq_decoded = []

  for i in Y1:

    real = np.real(i)
    imag = np.imag(i)

    eq_decoded.append(ispositive(real*-1))
    eq_decoded.append(ispositive(imag))

  eq_decoded = np.array(eq_decoded)

  err1 = 0
  for i in range(len(bits)):

    if allbits[0,:][i] != eq_decoded[i]:
      err1 += 1

  eq_decoded = []

  for i in Y2:

    real = np.real(i)
    imag = np.imag(i)

    eq_decoded.append(ispositive(real*-1))
    eq_decoded.append(ispositive(imag))

  eq_decoded = np.array(eq_decoded)

  err2 = 0
  for i in range(len(bits)):

    if allbits[1,:][i] != eq_decoded[i]:
      err2 += 1

  return err1/10000, err2/10000, noise

spatial_mux(5)

SD_BER1s = []
SD_BER2s = []
SD_SNRs = []
NP = np.linspace(0, 1000, 1000)

for i in NP:
  BER1, BER2, SNR = spatial_mux(i)

  SD_BER1s.append(BER1)
  SD_BER2s.append(BER2)
  SD_SNRs.append(SNR)

plt.figure(figsize=(25, 10))

plt.xlabel('Eb/No (dB)')
plt.ylabel('BER')

plt.grid(True)
plt.title('Bit Error Rate vs. SNR for MIMO System w/ Spatial Multiplexer')
plt.ylim(10E-4, 5E-1)
plt.plot(-10*np.log10(SD_SNRs), SD_BER1s, color='red', label='Channel 1')
plt.plot(-10*np.log10(SD_SNRs), SD_BER2s, color='blue', label='Channel 2')
plt.legend()

"""# BER vs MU"""

import numpy as np
import math
from cmath import exp
from math import cos
from math import sin

import matplotlib.pyplot as plt
import numpy as np
from matplotlib import animation, rc
from IPython.display import HTML
import cmath

ni = 1
nj = 2
N = ni**2 + ni*nj + nj**2
center = [0,0]
radius = 2000/np.sqrt(3)
labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
subscripts = ['\u2081', '\u2082', '\u2083', '\u2084', '\u2085', '\u2086', '\u2087']
frequencies = [1.8E9, 1.82E9, 1.84E9, 1.86E9, 1.88E9, 868E6, 882E6]

def hexangles(x): return np.pi*x/6

def drawCell(center,radius,label):
    pts = list(range(0,14,2))
    theta = list(map(hexangles,pts))
    xs = center[0]+radius*np.cos(theta)
    ys = center[1]+radius*np.sin(theta)
    plt.plot(xs,ys,'b-')
    plt.text(center[0],center[1],label)

def findServingCell(mobileLocation, cellCenters):
  distances = [np.sqrt((mobileLocation[0]-cell[0])**2 + (mobileLocation[1]-cell[1])**2)  for cell in cellCenters]
  return distances.index(min(distances)), min(distances)

channels = [[0,0]]
zippedcells = []

fig = plt.figure()
ax = plt.gca()
ax.set_aspect(1)

ax.set_title('Array Antenna Uplink Animation')
ax.set_xlabel('X (meters)')
ax.set_ylabel('Y (meters)')

plt.rcParams['animation.ffmpeg_path'] = '/usr/local/bin/ffmpeg'
numFrames = 60
ims=[]
mobilePosX = np.linspace(-50, 50,numFrames)
mobilePosY = np.linspace(-50,50,numFrames)


mobileAngle = np.arange(0, 2*np.pi, 2*np.pi/numFrames)
#mobilePosX = [40*cos(x) for x in mobileAngle]
#mobilePosY = [40*sin(x) for x in mobileAngle]



zippedcells = []
distances = []
targetcells = []
drawCell([0,0], 100, 'Smart Array')
angles = []

for frames in range(numFrames):
   
   # Find the corresponding serving cell
   idx, distance = findServingCell([mobilePosX[frames],mobilePosY[frames]], [[0,0]])

   #print(channels[idx][0])
   distances.append(distance)
   #targetcells.append(zippedcells[idx])
   # Draw a line connecting the center (basestation) of the serving cell 
   # and the mobile user
   #im, = plt.plot([0,mobilePosX[frames]],[0,mobilePosY[frames]], marker = 'x', color = 'red', animated=True)

   im, = plt.plot( [0,mobilePosX[frames]], [0,mobilePosY[frames]], marker = 'x', color = 'red', animated=True)
   theta = math.atan2(mobilePosY[frames], mobilePosX[frames])
   #theta = (theta+2*np.pi)%(2*np.pi)
   angles.append(theta)



   # Draw the mobile user at the appropriate location
   #im2, = plt.plot(mobilePosX[frames],mobilePosY[frames],'r+', animated=True)
    
   ims.append([im])

ani = animation.ArtistAnimation(fig, ims, interval=50, blit=True, repeat_delay=1000)

rc('animation', html='jshtml')
ani
#ani.save('user.gif', writer='pillow')
#plt.show()

def bs_power(d):
  return 0 - 10*2.9*np.log10(d)

power = [bs_power(x) for x in distances]

"""# MISO SD"""

BERsdistance = []
SNRsdistance = []
No = 17

for i in power:
  
  BER, SNR = miso_simulator(No*abs(i))
  BERsdistance.append(BER)
  SNRsdistance.append(No*abs(i))

movepattern = np.append(np.negative(distances[:30]), distances[30:60])

plt.figure(figsize=(25, 10))

plt.xlabel('Distance')
plt.ylabel('BER')

plt.grid(True)
plt.title('Bit Error Rate vs. Mobile User Distance (Selection Diversity)')
plt.plot(movepattern, BERsdistance)

plt.figure(figsize=(25, 10))

plt.xlabel('Distance')
plt.ylabel('SNR (dB)')

plt.grid(True)
plt.title('SNR vs. Mobile User Distance (Selection Diversity)')
plt.plot(movepattern, -10*np.log10(SNRsdistance))

"""# MISO SD mrc"""

BERsdistance = []
SNRsdistance = []
No = 17

for i in power:
  
  BER, SNR = miso_simulator_mrc(No*abs(i))
  BERsdistance.append(BER)
  SNRsdistance.append(No*abs(i))

movepattern = np.append(np.negative(distances[:30]), distances[30:60])

plt.figure(figsize=(25, 10))

plt.xlabel('Distance')
plt.ylabel('BER')

plt.grid(True)
plt.title('Bit Error Rate vs. Mobile User Distance (Maximum Ratio Combining)')
plt.plot(movepattern, BERsdistance)

plt.figure(figsize=(25, 10))

plt.xlabel('Distance')
plt.ylabel('SNR (dB)')

plt.grid(True)
plt.title('SNR vs. Mobile User Distance (Maximum Ratio Combining)')
plt.plot(movepattern, -10*np.log10(SNRsdistance))

"""# MIMO SD Mux"""

BER1sdistance = []
BER2sdistance = []
SNRsdistance = []
No = 17

for i in power:
  
  BER1, BER2, SNR = spatial_mux(No*abs(i))
  BER1sdistance.append(BER1)
  BER2sdistance.append(BER2)
  SNRsdistance.append(No*abs(i))

movepattern = np.append(np.negative(distances[:30]), distances[30:60])

plt.figure(figsize=(25, 10))

plt.xlabel('Distance')
plt.ylabel('BER')

plt.grid(True)
plt.title('Bit Error Rate vs. Mobile User Distance (Spatial Multiplexing)')
plt.plot(movepattern, BER1sdistance, label='Channel 1')
plt.plot(movepattern, BER2sdistance, label='Channel 2')
plt.legend()

plt.figure(figsize=(25, 10))

plt.xlabel('Distance')
plt.ylabel('SNR (dB)')

plt.grid(True)
plt.title('SNR vs. Mobile User Distance (Selection Diversity)')
plt.plot(movepattern, -10*np.log10(SNRsdistance))